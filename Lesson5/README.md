iOS 最详细的解析（数组与指针）笔试题

错误想法：
有的人认为
NSLog(@"%d", *(&arrayName + 1 - 1));
加1减1不就是抵消了么，那肯定是访问数组首地址，那打印的值肯定是 10,
看起来是通的（引用宋小宝小品海参炒面一句话：汤面没给钱，汤面用炒面换得给什么钱？炒面也没给钱啊，炒面没吃给什么钱？）但是含义是不一样的。

指针是如何加减运算：
int *p 的解释：将来的指针是指向int类型
指针p + 1 说明内存地址会加上4个字节（因为是int占4个字节）
如果是 double *p 指针p + 1内存地址会加上8个字节（因为是double占8个字节）
通过上述解释我们得出一个公式：
指针p + n = p当前的地址值 + n *指向类型所占用的字节数
指针p - n = p当前的地址值 - n * 指向类型所占用的字节数
数组与指针：
int arrayName[4] = {10, 20, 30, 40};

上面的数组占16个字节（原因：每个int类型占4个字节，这个数组有4个int类型，所以占16个字节）
arrayName就是数组名
数组名 :表示数组首元素的地址，相当于一个指向数组首元素的指针
相信你已经有点蒙圈了，我们在进一步解释一下：
NSLog(@"%p %p", arrayName, arrayName + 1);
 NSLog(@"%p %p", &arrayName, &arrayName + 1);


打印值.png
1. arrayName 与 &arrayName
arrayName 是数组名，所以打印出来是数组首元素的地址
&arrayName 含义就是数组的地址（等价于指向arrayName数组的指针），因为没增加1，所以数组的地址就是数组首元素的地址所以 arrayName <->&arrayName 打印出的地址是一样的

2.（arrayName + 1） 与 （&arrayName + 1）
（arrayName + 1）通过上述解释我们知道（arrayName + 1）指针是指向int类型，所以内存地址会加上4个字节
（&arrayName + 1）我们知道&arrayName是数组的地址（等价于指向arrayName数组的指针） 因为增加1，这个数组总共占16个字节，所以内存地址会加上16个字节

最后答案解析
    int arrayName[4] = {10, 20, 30, 40};
    /**
     1.(&arrayName + 1)：&arrayName是数组的地址（等价于指向arrayName数组的指针）
     2.增加 1 会往后移动16个字节，开始是4个字节的位置，移动后就是16个字节后面的位置（也就是目前位置是20个字节）
     3.最后又赋值给，int类型的指针p（int类型占4个字节）
     4.所以(p - 1)就是减去4个字节，变成为16个字节的位置，输出的*(p - 1)值为40
     */
    int *p = (int *)(&arrayName + 1);
    NSLog(@"%d", *(p - 1));//输出结果为 40






